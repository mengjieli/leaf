var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var engine;
(function (engine) {
    var BitmapProgram = (function (_super) {
        __extends(BitmapProgram, _super);
        function BitmapProgram(gl, stageWidth, stageHeight) {
            _super.call(this);
            this.projectionMatrix = new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                -1, 1, 0, 1]);
            this.textures = [];
            this.texturesSize = [];
            this.count = [];
            this.positionData = [];
            this.initProgram(gl);
            this.initAttriLocation(gl, stageWidth, stageHeight);
        }
        BitmapProgram.prototype.initProgram = function (gl) {
            var vertexSource = "\n            #ifdef GL_ES\n                precision mediump float;\n             #endif\n             attribute vec2 a_TexCoord;\n             attribute vec4 a_Position;\n             uniform mat4 u_PMatrix;\n             uniform vec2 u_TexSize;\n             varying vec2 v_TexCoord;\n             void main(void)\n             {\n                gl_Position = u_PMatrix*a_Position;\n                v_TexCoord = a_TexCoord;\n                //vec2 rcpFrame = vec2(1.0/u_TexSize.x, 1.0/u_TexSize.y);\n                //v_TexCoord.xy = a_TexCoord.xy;\n                //v_TexCoord.zw = a_TexCoord.xy - (rcpFrame * (0.5 + 1.0/4.0));\n             }\n             ";
            var fragmentSource = "\n            #ifdef GL_ES\n                precision mediump float;\n             #endif\n             varying vec2 v_TexCoord;\n\n             uniform sampler2D u_Sampler;\n             uniform vec2 u_TexSize;\n\n             vec4 fxaa(sampler2D, vec2, vec2,vec2, vec2,vec2, vec2,vec2);\n             vec4 fix(sampler2D, vec2,vec2);\n             vec4 fdfilter(sampler2D,vec2,vec2);\n             vec4 mskfilter(sampler2D,vec2,vec2,vec2);\n             vec4 mskrfilter(sampler2D,vec2,vec2,vec2);\n\n             void main(void)\n             {\n\n                //gl_FragColor = fix(u_Sampler,v_TexCoord,u_TexSize);\n\n                //gl_FragColor = fxaa(\n                //u_Sampler,\n                //vec2(v_TexCoord.x*u_TexSize.x,v_TexCoord.y*u_TexSize.y),\n                //u_TexSize,\n                ////vec2(v_TexCoord.x - (0.5 + 1.0/4.0)/u_TexSize.x                  , v_TexCoord.y - (0.5 + 1.0/4.0)/u_TexSize.y                  ),\n                ////vec2(v_TexCoord.x - (0.5 + 1.0/4.0)/u_TexSize.x + 1.0/u_TexSize.x, v_TexCoord.y - (0.5 + 1.0/4.0)/u_TexSize.y                  ),\n                ////vec2(v_TexCoord.x - (0.5 + 1.0/4.0)/u_TexSize.x                  , v_TexCoord.y - (0.5 + 1.0/4.0)/u_TexSize.y + 1.0/u_TexSize.y),\n                ////vec2(v_TexCoord.x - (0.5 + 1.0/4.0)/u_TexSize.x + 1.0/u_TexSize.x, v_TexCoord.y - (0.5 + 1.0/4.0)/u_TexSize.y + 1.0/u_TexSize.y),\n                //\n                ////vec2(v_TexCoord.z                  , v_TexCoord.w                  ),\n                ////vec2(v_TexCoord.z + 1.0/u_TexSize.x, v_TexCoord.w                  ),\n                ////vec2(v_TexCoord.z                  , v_TexCoord.w + 1.0/u_TexSize.y),\n                ////vec2(v_TexCoord.x + 1.0/u_TexSize.x, v_TexCoord.y + 1.0/u_TexSize.y),\n                //\n                ////vec2(v_TexCoord.x - 1.0/u_TexSize.x, v_TexCoord.y                  ),\n                ////vec2(v_TexCoord.x + 1.0/u_TexSize.x, v_TexCoord.y                  ),\n                ////vec2(v_TexCoord.x                  , v_TexCoord.y - 1.0/u_TexSize.y),\n                ////vec2(v_TexCoord.x                  , v_TexCoord.y + 1.0/u_TexSize.y),\n                //\n                //vec2(v_TexCoord.x - 1.0/u_TexSize.x, v_TexCoord.y - 1.0/u_TexSize.y),\n                //vec2(v_TexCoord.x + 1.0/u_TexSize.x, v_TexCoord.y - 1.0/u_TexSize.y),\n                //vec2(v_TexCoord.x - 1.0/u_TexSize.x, v_TexCoord.y + 1.0/u_TexSize.y),\n                //vec2(v_TexCoord.x + 1.0/u_TexSize.x, v_TexCoord.y + 1.0/u_TexSize.y),\n                //\n                //v_TexCoord.xy);\n\n                gl_FragColor = texture2D(u_Sampler,v_TexCoord);\n\n                //\u6D6E\u96D5\u6548\u679C\n                //gl_FragColor = fdfilter(u_Sampler,v_TexCoord,u_TexSize);\n\n                //\u9A6C\u8D5B\u514B\u6EE4\u955C\n                //gl_FragColor = mskfilter(u_Sampler,v_TexCoord,u_TexSize,vec2(8,8));\n\n                //\u5706\u5F62\u9A6C\u8D5B\u514B\n                //gl_FragColor = mskrfilter(u_Sampler,v_TexCoord,u_TexSize,vec2(16,16));\n             }\n\n             //\u9A6C\u8D5B\u514B\u6EE4\u955C\n             vec4 mskfilter(sampler2D s_baseMap,vec2 v_texCoord,vec2 TexSize,vec2 mosaicSize)\n             {\n                vec2 intXY = vec2(v_texCoord.x*TexSize.x, v_texCoord.y*TexSize.y);\n                vec2 XYMosaic = vec2(floor(intXY.x/mosaicSize.x)*mosaicSize.x,floor(intXY.y/mosaicSize.y)*mosaicSize.y);\n                vec2 UVMosaic = vec2(XYMosaic.x/TexSize.x,XYMosaic.y/TexSize.y);\n                return texture2D(s_baseMap,UVMosaic);\n             }\n\n             //\u5706\u5F62\u9A6C\u8D5B\u514B\u6EE4\u955C\n             vec4 mskrfilter(sampler2D s_baseMap,vec2 v_texCoord,vec2 TexSize,vec2 mosaicSize)\n             {\n                vec2 intXY = vec2(v_texCoord.x*TexSize.x, v_texCoord.y*TexSize.y);\n                vec2 XYMosaic = vec2(floor(intXY.x/mosaicSize.x)*mosaicSize.x,floor(intXY.y/mosaicSize.y)*mosaicSize.y) + 0.5*mosaicSize;\n                vec2 delXY = XYMosaic - intXY;\n                float delL = length(delXY);\n                vec2 UVMosaic = vec2(XYMosaic.x/TexSize.x,XYMosaic.y/TexSize.y);\n                if(delL< 0.5*mosaicSize.x) {\n                    return texture2D(s_baseMap,UVMosaic);\n                }\n                return texture2D(s_baseMap,v_texCoord);\n\n             }\n\n             //\u6D6E\u96D5\u6EE4\u955C\n             vec4 fdfilter(sampler2D sampler,vec2 texCoord,vec2 texSize)\n             {\n                vec2 tex = texCoord;\n                vec2 upLeftUV = vec2(tex.x-1.0/texSize.x,tex.y-1.0/texSize.y);\n                vec4 curColor = texture2D(sampler,tex);\n                vec4 upLeftColor = texture2D(sampler,upLeftUV);\n                vec4 delColor = curColor - upLeftColor;\n                float h = 0.3*delColor.x + 0.59*delColor.y + 0.11*delColor.z;\n                vec4 bkColor = vec4(0.5, 0.5, 0.5, 1.0);\n                return vec4(h,h,h,0.0) + bkColor;\n             }\n\n\n            #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n            #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n            #define FXAA_SPAN_MAX     8.0\n\n            //optimized version for mobile, where dependent\n            //texture reads can be a bottleneck\n            vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n                        vec2 v_rgbNW, vec2 v_rgbNE,\n                        vec2 v_rgbSW, vec2 v_rgbSE,\n                        vec2 v_rgbM) {\n                vec4 color;\n                mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n                vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n                vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n                vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n                vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n                vec4 texColor = texture2D(tex, v_rgbM);\n                vec3 rgbM  = texColor.xyz;\n                vec3 luma = vec3(0.299, 0.587, 0.114);\n                float lumaNW = dot(rgbNW, luma);\n                float lumaNE = dot(rgbNE, luma);\n                float lumaSW = dot(rgbSW, luma);\n                float lumaSE = dot(rgbSE, luma);\n                float lumaM  = dot(rgbM,  luma);\n                float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n                float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n                mediump vec2 dir;\n                dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n                dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n                float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                                      (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n                float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n                dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n                          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                          dir * rcpDirMin)) * inverseVP;\n\n                vec3 rgbA = 0.5 * (\n                    texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                    texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n                vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                    texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                    texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n                float lumaB = dot(rgbB, luma);\n                if ((lumaB < lumaMin) || (lumaB > lumaMax))\n                    color = vec4(rgbA, texColor.a);\n                else\n                    color = vec4(rgbB, texColor.a);\n                return color;\n            }\n             ";
            var vertexShader = engine.Program.createShader(gl, gl.VERTEX_SHADER, vertexSource);
            var fragmentShader = engine.Program.createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
            this.program = engine.Program.createWebGLProgram(gl, vertexShader, fragmentShader);
        };
        BitmapProgram.prototype.initAttriLocation = function (gl, width, height) {
            var projectionMatrix = this.projectionMatrix;
            projectionMatrix[0] = 2 / width;
            projectionMatrix[5] = -2 / height;
            var program = this.program;
            program["name"] = "bitmap program";
            gl.useProgram(this.program);
            if (!this.buffer) {
                this.buffer = gl.createBuffer();
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            this.a_Position = gl.getAttribLocation(program, "a_Position");
            gl.enableVertexAttribArray(this.a_Position);
            gl.vertexAttribPointer(this.a_Position, 2, gl.FLOAT, false, engine.$size * 4, 0);
            this.a_TexCoord = gl.getAttribLocation(program, "a_TexCoord");
            gl.enableVertexAttribArray(this.a_TexCoord);
            gl.vertexAttribPointer(this.a_TexCoord, 2, gl.FLOAT, false, engine.$size * 4, engine.$size * 2);
            var u_PMatrix = gl.getUniformLocation(program, "u_PMatrix");
            gl.uniformMatrix4fv(u_PMatrix, false, projectionMatrix);
            this.u_TexSize = gl.getUniformLocation(program, "u_TexSize");
            //console.log(gl.getAttribLocation(program,"a_Position"));
        };
        BitmapProgram.prototype.reset = function () {
            var _this = this;
            _this.textures = [];
            _this.texturesSize = [];
            _this.count = [];
            _this.positionData = [];
        };
        BitmapProgram.prototype.addDisplayObject = function (display) {
            if (!display.texture) {
                return;
            }
            if (!this.textures.length || this.textures[this.textures.length - 1] != display.texture) {
                this.textures.push(display.texture);
                this.texturesSize.push([display.width, display.height]);
                this.positionData.push([]);
                this.count.push(0);
            }
            var index = this.count[this.count.length - 1] * 24;
            var positionData = this.positionData[this.positionData.length - 1];
            var matrix = display.matrix;
            positionData[index] = matrix.b + matrix.tx;
            positionData[1 + index] = matrix.d * display.height + matrix.ty;
            positionData[2 + index] = 0.0;
            positionData[3 + index] = 1.0;
            positionData[16 + index] = positionData[4 + index] = matrix.tx;
            positionData[17 + index] = positionData[5 + index] = matrix.ty;
            positionData[18 + index] = positionData[6 + index] = 0.0;
            positionData[19 + index] = positionData[7 + index] = 0.0;
            positionData[12 + index] = positionData[8 + index] = matrix.a * display.width + matrix.b + matrix.tx;
            positionData[13 + index] = positionData[9 + index] = matrix.c + matrix.d * display.height + matrix.ty;
            positionData[14 + index] = positionData[10 + index] = 1.0;
            positionData[15 + index] = positionData[11 + index] = 1.0;
            positionData[20 + index] = matrix.a * display.width + matrix.tx;
            positionData[21 + index] = matrix.c + matrix.ty;
            positionData[22 + index] = 1.0;
            positionData[23 + index] = 0.0;
            this.count[this.count.length - 1]++;
        };
        BitmapProgram.prototype.render = function (gl) {
            var _this = this;
            gl.useProgram(_this.program);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.vertexAttribPointer(_this.a_Position, 2, gl.FLOAT, false, engine.$size * 4, 0);
            gl.vertexAttribPointer(_this.a_TexCoord, 2, gl.FLOAT, false, engine.$size * 4, engine.$size * 2);
            for (var i = 0, len = _this.textures.length; i < len; i++) {
                gl.uniform2f(this.u_TexSize, this.texturesSize[i][0], this.texturesSize[i][1]);
                gl.bindTexture(gl.TEXTURE_2D, _this.textures[i]);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(_this.positionData[i]), gl.STATIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, 0, 6 * _this.count[i]);
            }
        };
        return BitmapProgram;
    })(engine.Program);
    engine.BitmapProgram = BitmapProgram;
})(engine || (engine = {}));
var str = "\n    #define FXAA_PRESET 3\n    #define FXAA_HLSL_4 1\n    #include \u201CFxaaShader.h\u201D\n    cbuffer cbFxaa : register(b1)\n    {\n        float4 rcpFrame : packoffset(c0);\n    };\n    struct FxaaVS_Output\n    {\n        float4 Pos : SV_POSITION;\n        float2 Tex : TEXCOORD0;\n    };\n     FxaaVS_Output FxaaVS (uint id : SV_VertexID)\n    {\n         FxaaVS_Output Output;\n         Output.Tex = float2((id << 1) & 2, id & 2);\n         Output.Pos = float4(Output.Tex * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f), 0.0f, 1.0f);\n         return Output;\n    }\n    SamplerState anisotropicSampler : register(s0);\n    Texture2D inputTexture : register(t0);\n    float4 FxaaPS(FxaaVS_Output Input) : SV_TARGET\n    {\n        FxaaTex tex = { anisotropicSampler, inputTexture };\n         return float4(FxaaPixelShader( Input.Tex.xy, tex, rcpFrame.xy), 1.0f);\n    }\n\n    \u6CE8\u610F\uFF0CFXAA\u9884\u7F6E0\u901A\u8FC72\u9700\u8981\u6700\u5927\u5404\u5411\u5F02\u6027\u91C7\u6837\n    \u5404\u5411\u5F02\u6027\u7684\u8BBE\u7F6E\u4E3A4\uFF0C\u5E76\u4E3A\u6240\u6709\u7684\u9884\u8BBE\uFF0C\u6709\u9700\u8981\u7684rcpframe\u5E38\u6570\n    \u7535\u6E90\u8F93\u5165\u7EB9\u7406\u50CF\u7D20\u5927\u5C0F\u7684\u5012\u6570\uFF0C\n\n    Note, FXAA presets 0 through 2 require an anisotropic sampler with max\n    anisotropy set to 4, and for all presets, there is a required rcpFrame constant which\n    supplies the reciprocal of the inputTexture size in pixels,\n\n    { 1.0f/inputTextureWidth, 1.0f/inputTextureHeight, 0.0f, 0.0f }\n\n    \u4F5C\u4E3A\u4E00\u4E2A\u4F18\u5316\uFF0C\u4EAE\u5EA6\u4F30\u8BA1\u4E25\u683C\u4ECE\u7EA2\u8272\u548C\u7EFF\u8272\u901A\u9053\n    \u4F7F\u7528\u5355\u4E00\u7684\u7194\u878D\u4E58\u6CD5\u8FD0\u7B97\u3002\u5728\u5B9E\u8DF5\u4E2D\uFF0C\u7EAF\u84DD\u6DF7\u53E0\u5F88\u5C11\n    \u5178\u578B\u7684\u6E38\u620F\u5185\u5BB9\u3002\n\n    float FxaaLuma(float3 rgb)\n    {\n        return rgb.y * (0.587/0.299) + rgb.x;\n    }\n\n    \u672C\u5730\u5BF9\u6BD4\u68C0\u67E5\u4F7F\u7528\u50CF\u7D20\u53CA\u5176\u5317\u3001\u5357\u3001\u4E1C\u3001\u897F\n    \u90BB\u5C45\u3002\u5982\u679C\u5DEE\u5F02\u5728\u5F53\u5730\u6700\u5927\u548C\u6700\u5C0F\u4EAE\u5EA6\uFF08\u5BF9\u6BD4\u5EA6\uFF09\u662F\n    \u4F4E\u4E8E\u9608\u503C\u7684\u6700\u5927\u5C40\u90E8\u7684\u4EAE\u5EA6\u6BD4\u4F8B\uFF0C\u7136\u540E\u7740\u8272\n    \u65E9\u671F\u9000\u51FA\uFF08\u6CA1\u6709\u660E\u663E\u7684\u6DF7\u53E0\uFF09\u3002\u8FD9\u4E2A\u9608\u503C\u662F\u4EE5\u6700\u5C0F\u503C\u6765\u8FDB\u884C\u7684\n    \u907F\u514D\u5728\u771F\u6B63\u7684\u9ED1\u6697\u9886\u57DF\u7684\u5904\u7406\u3002\n\n    float3 rgbN = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 0,-1)).xyz;\n    float3 rgbW = FxaaTextureOffset(tex, pos.xy, FxaaInt2(-1, 0)).xyz;\n    float3 rgbM = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 0, 0)).xyz;\n    float3 rgbE = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 1, 0)).xyz;\n    float3 rgbS = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 0, 1)).xyz;\n    float lumaN = FxaaLuma(rgbN);\n    float lumaW = FxaaLuma(rgbW);\n    float lumaM = FxaaLuma(rgbM);\n    float lumaE = FxaaLuma(rgbE);\n    float lumaS = FxaaLuma(rgbS);\n    float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));\n    float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));\n    float range = rangeMax - rangeMin;\n    if(range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * XAA_EDGE_THRESHOLD))\n    {\n     return FxaaFilterReturn(rgbM);\n    }\n\n    \u8FD9\u4E9B\u5B9A\u4E49\u53EF\u4EE5\u7528\u6765\u4F18\u5316\u7B97\u6CD5\uFF0C\u901A\u8FC7\u5141\u8BB8\u8BE5\u7B97\u6CD5\u65E9\u671F\n    \u9000\u51FA\u548C\u907F\u514D\u5904\u7406\u3002\n    fxaa_edge_threshold\n    \u5E94\u7528\u7B97\u6CD5\u6240\u9700\u7684\u6700\u5C0F\u5C40\u90E8\u5BF9\u6BD4\u5EA6\u3002\n    1 / 3 -\u592A\u5C11\n    1 / 4 -\u4F4E\u8D28\u91CF\n    1 / 8 -\u9AD8\u8D28\u91CF\n    1 / 16\u2013\u77EB\u6789\u8FC7\u6B63\n    fxaa_edge_threshold_min\n    \u4FEE\u526A\u5904\u7406\u6697\u90E8\u7684\u7B97\u6CD5\u3002\n    1 / 32 -\u53EF\u89C1\u9650\n    1 / 16 -\u9AD8\u8D28\u91CF\n    1 / 12\u2013\u4E0A\u9650\uFF08\u53EF\u89C1\u672A\u8FC7\u6EE4\u7684\u8FB9\u7F18\u5F00\u59CB\uFF09\n\n\n    \u50CF\u7D20\u5BF9\u6BD4\u5EA6\u4F30\u8BA1\u4E3A\u4ECE\u4F4E\u50CF\u7D20\u4EAE\u5EA6\u7684\u7EDD\u5BF9\u5DEE\u5F02\n    \u4EAE\u5EA6\uFF08\u8BA1\u7B97\u4E3A\u5317\uFF0C\u5E73\u5747\u5357\uFF0C\u4E1C\u548C\u897F\u7684\u90BB\u5C45\uFF09\u3002\u8FD9\u4E2A\n    \u50CF\u7D20\u5BF9\u6BD4\u5EA6\u4E0E\u5C40\u90E8\u5BF9\u6BD4\u5EA6\u662F\u7528\u6765\u68C0\u6D4B\u4E9A\u50CF\u7D20\u6DF7\u53E0\u3002\u8FD9\u4E2A\u6BD4\u4F8B\n    \u63A5\u8FD11\u5728\u5355\u4E00\u50CF\u7D20\u70B9\u7684\u5B58\u5728\uFF0C\u5426\u5219\u5F00\u59CB\u8131\u843D\n    \u671D\u77400\u50CF\u7D20\u7684\u8FB9\u7F18\u8D21\u732E\u66F4\u591A\u3002\u6BD4\u4F8B\u8F6C\u5316\u4E3A\n    \u878D\u5165\u5728\u7B97\u6CD5\u7ED3\u675F\u4F4E\u901A\u6EE4\u6CE2\u5668\u7684\u6570\u91CF\u3002\n\n    float lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25;\n    float rangeL = abs(lumaL - lumaM);\n    float blendL = max(0.0, (rangeL / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE;\n    blendL = min(FXAA_SUBPIX_CAP, blendL);\n\n    \u7528\u4E8E\u8FC7\u6EE4\u50CF\u7D20\u8D70\u6837\u7B97\u6CD5\u540E\u671F\u7684\u4F4E\u503C\u662F\u5B8C\u6574\u76843x3\u50CF\u7D20\u90BB\u57DF\u7BB1\u5F0F\u8FC7\u6EE4\u5668\u3002\n\n    float3 rgbL = rgbN + rgbW + rgbM + rgbE + rgbS;\n    // ...\n    float3 rgbNW = FxaaTextureOffset(tex, pos.xy, FxaaInt2(-1,-1)).xyz;\n    float3 rgbNE = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 1,-1)).xyz;\n    float3 rgbSW = FxaaTextureOffset(tex, pos.xy, FxaaInt2(-1, 1)).xyz;\n    float3 rgbSE = FxaaTextureOffset(tex, pos.xy, FxaaInt2( 1, 1)).xyz;\n    rgbL += (rgbNW + rgbNE + rgbSW + rgbSE);\n    rgbL *= FxaaToFloat3(1.0/9.0);\n\n    \u9664\u4E86\u5173\u95ED\u529F\u80FD\u6216\u5B8C\u5168\u7684\uFF0C\u8FD9\u4E9B\u5B9A\u4E49\u4E0D\u5F71\u54CD\n    \u6027\u80FD\u3002\u901A\u8FC7\u9ED8\u8BA4\u7684\u5B50\u50CF\u7D20\u6DF7\u53E0\u6D88\u9664\u7684\u91CF\u662F\u6709\u9650\u7684\u3002\u8FD9\n    \u53EF\u4EE5\u4FDD\u6301\u826F\u597D\u7684\u529F\u80FD\uFF0C\u4F46\u5728\u4E00\u4E2A\u4F4E\u7684\u5BF9\u6BD4\u5EA6\uFF0C\u6240\u4EE5\u4ED6\u4EEC\u4E0D\n    \u5206\u6563\u6CE8\u610F\u529B\u7684\u773C\u775B\u3002\u6EE1\u662F\u6A21\u7CCA\u7684\u56FE\u50CF\u3002\n    fxaa_subpix\n    \u5207\u6362subpix\u8FC7\u6EE4\u3002\n    0\uFF0C\u5173\u95ED\n    1\uFF0C\u6253\u5F00\n    2\u2013\u6253\u5F00\u529B\uFF08\u5FFD\u7565fxaa_subpix_trim\u5E3D\uFF09\n    fxaa_subpix_trim\n    \u63A7\u5236\u53BB\u9664\u5B50\u50CF\u7D20\u6DF7\u53E0\u3002\n    1 / 2 -\u4F4E\u53BB\u9664\n    1 / 3 -\u4E2D\u53BB\u9664\n    1 / 4 -\u9ED8\u8BA4\u6E05\u9664\n    1 / 8 -\u9AD8\u53BB\u9664\n    0\u5F7B\u5E95\u6E05\u9664\n    fxaa_subpix_cap\n    \u786E\u4FDD\u7EC6\u8282\u6CA1\u6709\u5B8C\u5168\u6D88\u9664\u3002\n    \u8FD9\u90E8\u5206\u8986\u76D6fxaa_subpix_trim\u3002\n    3 / 4 -\u9ED8\u8BA4\u7684\u8FC7\u6EE4\u91CF\n    7 / 8 -\u8FC7\u6EE4\u91CF\n    1\u3001\u65E0\u65CB\u76D6\n\n    \u8FB9\u7F18\u68C0\u6D4B\u6EE4\u6CE2\u5668\uFF0C\u5982Sobel\u5355\u50CF\u7D20\u7EBF\u7A7F\u8D8A\u4E2D\u5FC3\u5931\u8D25\n    \u4E00\u4E2A\u50CF\u7D20\u3002FXAA\u4EE5\u52A0\u6743\u5E73\u5747\u5E45\u5EA6\u7684\u9AD8\u901A\u503C\n    \u5F53\u5730\u76843x3\u90BB\u57DF\u7684\u884C\u548C\u5217\u7684\u5C40\u90E8\u8FB9\u7F18\u7684\u6307\u793A\n    \u6570\u91CF\u3002\n\n    float edgeVert =\n     abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +\n     abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +\n     abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));\n    float edgeHorz =\n     abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +\n     abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +\n     abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));\n    bool horzSpan = edgeHorz >= edgeVert;\n\n    \u9274\u4E8E\u5F53\u5730\u7684\u8FB9\u7F18\u65B9\u5411\uFF0CFXAA\u5BF9\u50CF\u7D20\u7684\u6700\u9AD8\u5BF9\u6BD4\u5EA6\n    \u90BB\u5C4590\u5EA6\u5230\u672C\u5730\u8FB9\u65B9\u5411\u3002\u7B97\u6CD5\u641C\u7D22\u6CBF\n    \u5728\u6B63\u9762\u548C\u8D1F\u9762\u7684\u65B9\u5411\uFF0C\u76F4\u5230\u8FBE\u5230\u4E00\u4E2A\u641C\u7D22\u9650\u5236\u6216\n    \u6CBF\u8FB9\u7F18\u53D8\u5316\u7684\u5E73\u5747\u4EAE\u5EA6\u53D8\u5316\uFF0C\u4EE5\u8868\u793A\n    \u8FB9\u7AEF\u3002\n    \u4E00\u4E2A\u5355\u72EC\u7684\u5FAA\u73AF\u641C\u7D22\u7684\u8D1F\u548C\u6B63\u65B9\u5411\u5E73\u884C\u7684\n    \u9009\u62E9\u6C34\u5E73\u65B9\u5411\u6216\u5782\u76F4\u65B9\u5411\u3002\u8FD9\u6837\u505A\u662F\u4E3A\u4E86\u907F\u514D\u53D1\u6563\u5206\u652F\n    \u5728\u6750\u8D28\u3002\n    \u5F53\u641C\u7D22\u52A0\u901F\u542F\u7528\uFF08\u9884\u8BBE0\uFF0C1\uFF0C2\uFF09\u641C\u7D22\u52A0\u901F\n    \u4F7F\u7528\u5404\u5411\u5F02\u6027\u8FC7\u6EE4\u4F5C\u4E3A\u4E00\u4E2A\u65B9\u5757\u8FC7\u6EE4\u5668\uFF0C\u4EE5\u68C0\u67E5\u8D85\u8FC7\u4E00\u4E2A\u5355\u4E00\u7684\u50CF\u7D20\u5BF9\u3002\n\n    for(uint i = 0; i < FXAA_SEARCH_STEPS; i++)\n    {\n        #if FXAA_SEARCH_ACCELERATION == 1\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexture(tex, posN.xy).xyz);\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexture(tex, posP.xy).xyz);\n        #else\n            if(!doneN) lumaEndN = FxaaLuma;\n            FxaaTextureGrad(tex, posN.xy, offNP).xyz);\n            if(!doneP) lumaEndP = FxaaLuma;\n            FxaaTextureGrad(tex, posP.xy, offNP).xyz);\n        #endif\n        doneN = doneN || (abs(lumaEndN - lumaN) >= gradientN);\n        doneP = doneP || (abs(lumaEndP - lumaN) >= gradientN);\n        if(doneN && doneP) break;\n        if(!doneN) posN -= offNP;\n        if(!doneP) posP += offNP;\n    }\n";
//# sourceMappingURL=BitmapProgram.js.map